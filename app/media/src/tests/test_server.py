import io
import json
import os
import tempfile
from base64 import urlsafe_b64encode
from concurrent import futures
from contextlib import contextmanager
from datetime import datetime, timedelta
from urllib.parse import urlencode

import grpc
import pytest
from google.protobuf import empty_pb2
from google.protobuf.timestamp_pb2 import Timestamp
from media.server import create_app
from nacl.bindings.crypto_generichash import generichash_blake2b_salt_personal
from nacl.utils import random as random_bytes
from pb import api_pb2, media_pb2, media_pb2_grpc
from PIL import Image


class MockMainServer(media_pb2_grpc.MediaServicer):
    def __init__(self, bearer_token, accept_func):
        self._bearer_token = bearer_token
        self._accept_func = accept_func

    def UploadConfirmation(self, request, context):
        metadata = {key: value for (key, value) in context.invocation_metadata()}
        if ("authorization" not in metadata
            or not metadata["authorization"].startswith("Bearer ")
            or metadata["authorization"][7:] != self._bearer_token):
            context.abort(grpc.StatusCode.UNAUTHENTICATED, "Unauthorized")

        if self._accept_func(request):
            return empty_pb2.Empty()
        else:
            raise Exception("Didn't accept")

@contextmanager
def mock_main_server(*args, **kwargs):
    server = grpc.server(futures.ThreadPoolExecutor(1))
    port = server.add_secure_port("localhost:8088", grpc.local_server_credentials())
    servicer = MockMainServer(*args, **kwargs)
    media_pb2_grpc.add_MediaServicer_to_server(servicer, server)
    server.start()

    try:
        yield port
    finally:
        server.stop(None)

@pytest.fixture
def client_with_secrets(tmp_path):
    secret_key = random_bytes(32)
    bearer_token = random_bytes(32).hex()

    app = create_app(
        media_server_secret_key=secret_key,
        media_server_bearer_token=bearer_token,
        main_server_address="localhost:8088",
        main_server_use_ssl=False,
        media_upload_location=tmp_path,
        avatar_size=200,
    )

    app.config["TESTING"] = True

    with app.test_client() as client:
        yield client, secret_key, bearer_token

def Timestamp_from_datetime(dt: datetime):
    pb_ts = Timestamp()
    pb_ts.FromDatetime(dt)
    return pb_ts

def generate_hash_signature(message: bytes, key: bytes) -> bytes:
    """
    Computes a blake2b keyed hash for the message.

    This can be used as a fast yet secure symmetric signature: by checking that
    the hashes agree, we can make sure the signature was generated by a party
    with knowledge of the key.
    """
    return generichash_blake2b_salt_personal(message, key=key, digest_size=32)

def generate_upload_path(request, media_server_secret_key):
    req = request.SerializeToString()
    data = urlsafe_b64encode(req).decode("utf8")
    sig = urlsafe_b64encode(generate_hash_signature(req, media_server_secret_key)).decode("utf8")

    return "upload?" + urlencode({"data": data, "sig": sig})

def test_index(client_with_secrets):
    client, secret_key, bearer_token = client_with_secrets
    rv = client.get("/")
    assert b"404" in rv.data

def create_upload_request():
    key = random_bytes(32).hex()

    now = datetime.utcnow()
    expiry = now + timedelta(minutes=20)

    return key, media_pb2.UploadRequest(
        key=key,
        type=media_pb2.UploadRequest.UploadType.IMAGE,
        created=Timestamp_from_datetime(now),
        expiry=Timestamp_from_datetime(expiry),
        max_width=2000,
        max_height=1600,
    )

def test_image_upload(client_with_secrets):
    client, secret_key, bearer_token = client_with_secrets

    key, request = create_upload_request()
    upload_path = generate_upload_path(request, secret_key)

    with mock_main_server(bearer_token, lambda x: True):
        with open("tests/data/1x1.jpg", "rb") as f:

            data = {
                "file": (f, "1x1.jpg"),
            }

            rv = client.post(upload_path, data=data)

        assert json.loads(rv.data)["ok"]

def test_image_resizing(client_with_secrets):
    client, secret_key, bearer_token = client_with_secrets

    key, request = create_upload_request()
    upload_path = generate_upload_path(request, secret_key)

    with mock_main_server(bearer_token, lambda x: True):
        with open("tests/data/5000x5000.jpg", "rb") as f:

            data = {
                "file": (f, "img.jpg"),
            }

            rv = client.post(upload_path, data=data)

        assert json.loads(rv.data)["ok"]

        rv = client.get(f"/full/{key}.jpg")
        assert rv.status_code == 200

        img = Image.open(io.BytesIO(rv.data))

        assert img.width <= 2000
        assert img.height <= 1600

        assert img.width == 2000 or img.height == 1600

def test_image_pixel(client_with_secrets):
    client, secret_key, bearer_token = client_with_secrets

    key, request = create_upload_request()
    upload_path = generate_upload_path(request, secret_key)

    with mock_main_server(bearer_token, lambda x: True):
        with open("tests/data/1x1.jpg", "rb") as f:

            data = {
                "file": (f, "badfile.exe"),
            }

            rv = client.post(upload_path, data=data)

        assert json.loads(rv.data)["ok"]

        rv = client.get(f"/full/{key}.jpg")
        assert rv.status_code == 200

        img = Image.open(io.BytesIO(rv.data))

        assert img.width == 1
        assert img.height == 1

def test_bad_file(client_with_secrets):
    client, secret_key, bearer_token = client_with_secrets

    key, request = create_upload_request()
    upload_path = generate_upload_path(request, secret_key)

    with mock_main_server(bearer_token, lambda x: True):
        with open("tests/data/badfile.txt", "rb") as f:

            data = {
                # filename shouldn't matter
                "file": (f, "badfile.exe"),
            }

            rv = client.post(upload_path, data=data)

        assert rv.status_code == 400
